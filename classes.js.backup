// ===== NetworkNode Class =====
class NetworkNode {
    constructor(x, y) {
        this.id = state.nextNodeId++;
        this.x = x;
        this.y = y;
        this.width = 200;
        this.height = 100;
        this.label = `ノード ${this.id}`;
        this.color = '#21262d';
        this.memo = '';
        this.status = 'Active';
        this.classification = 'PC';
        this.managementId = '';
        this.modelNumber = '';
        this.location = '';
        this.installDate = '';
        this.disposalDate = '';
        this.link = '';
        this.elements = [];
        this.leftPorts = [
            { name: 'L1', id: `${this.id}-L1`, description: '', status: 'Active', classification: 'LAN', modelNumber: '', memo: '' },
            { name: 'L2', id: `${this.id}-L2`, description: '', status: 'Active', classification: 'LAN', modelNumber: '', memo: '' }
        ];
        this.rightPorts = [
            { name: 'R1', id: `${this.id}-R1`, description: '', status: 'Active', classification: 'LAN', modelNumber: '', memo: '' },
            { name: 'R2', id: `${this.id}-R2`, description: '', status: 'Active', classification: 'LAN', modelNumber: '', memo: '' }
        ];
        this.topPorts = [];
        this.bottomPorts = [];
        this.parentId = null;
        this.updateHeight();
    }

    addElement(name) {
        this.elements.push({
            id: `${this.id}-e${state.nextElementId++}`,
            name: name || `要素${this.elements.length + 1}`,
            description: '',
            status: 'Active',
            memo1: '',
            memo2: '',
            url: '',
            color: '#c9d1d9'
        });
        this.updateHeight();
    }

    removeElement(index) {
        this.elements.splice(index, 1);
        this.updateHeight();
    }

    updateHeight() {
        const headerHeight = 40;
        const padding = 15;
        const elementHeight = 25;
        const bottomPadding = 10;
        const contentHeight = headerHeight + padding + (this.elements.length * elementHeight) + bottomPadding;
        const maxPorts = Math.max(this.leftPorts.length, this.rightPorts.length);
        const minPortHeight = (maxPorts + 1) * 20;
        this.height = Math.max(contentHeight, minPortHeight, 100);
    }

    getPortPosition(portId) {
        const allPorts = [...this.leftPorts, ...this.rightPorts, ...this.topPorts, ...this.bottomPorts];
        const port = allPorts.find(p => p.id === portId);
        if (!port) return null;

        if (this.leftPorts.includes(port)) {
            const index = this.leftPorts.indexOf(port);
            const spacing = this.height / (this.leftPorts.length + 1);
            return { x: this.x, y: this.y + spacing * (index + 1), side: 'left' };
        } else if (this.rightPorts.includes(port)) {
            const index = this.rightPorts.indexOf(port);
            const spacing = this.height / (this.rightPorts.length + 1);
            return { x: this.x + this.width, y: this.y + spacing * (index + 1), side: 'right' };
        } else if (this.topPorts.includes(port)) {
            const index = this.topPorts.indexOf(port);
            const spacing = this.width / (this.topPorts.length + 1);
            return { x: this.x + spacing * (index + 1), y: this.y, side: 'top' };
        } else if (this.bottomPorts.includes(port)) {
            const index = this.bottomPorts.indexOf(port);
            const spacing = this.width / (this.bottomPorts.length + 1);
            return { x: this.x + spacing * (index + 1), y: this.y + this.height, side: 'bottom' };
        }
        return null;
    }

    getPortAtPosition(x, y) {
        const allPorts = [
            ...this.leftPorts.map(p => ({ ...p, side: 'left' })),
            ...this.rightPorts.map(p => ({ ...p, side: 'right' })),
            ...this.topPorts.map(p => ({ ...p, side: 'top' })),
            ...this.bottomPorts.map(p => ({ ...p, side: 'bottom' }))
        ];

        for (const port of allPorts) {
            const pos = this.getPortPosition(port.id);
            const dx = x - pos.x;
            const dy = y - pos.y;
            if (Math.sqrt(dx * dx + dy * dy) < 8) {
                return port;
            }
        }
        return null;
    }

    containsPoint(x, y) {
        return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;
    }

    getWidthResizeHandleAtPosition(x, y) {
        const handleSize = 12;
        const offset = 5; // Offset outside the node
        const handleX = this.x + this.width + offset;
        const handleY = this.y + this.height + offset;

        if (x >= handleX - handleSize / 2 && x <= handleX + handleSize / 2 &&
            y >= handleY - handleSize / 2 && y <= handleY + handleSize / 2) {
            return 'bottom-right';
        }
        return null;
    }

    draw(ctx, isSelected) {
        ctx.fillStyle = this.color;
        ctx.strokeStyle = isSelected ? '#58a6ff' : '#30363d';
        ctx.lineWidth = isSelected ? 2 : 1;
        ctx.beginPath();
        ctx.roundRect(this.x, this.y, this.width, this.height, 6);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(this.x, this.y + 40);
        ctx.lineTo(this.x + this.width, this.y + 40);
        ctx.strokeStyle = '#30363d';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = '#c9d1d9';
        ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.label, this.x + this.width / 2, this.y + 20);

        let currentY = this.y + 55;
        ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif';
        ctx.textAlign = 'left';

        this.elements.forEach(el => {
            ctx.fillStyle = el.color || '#8b949e';
            ctx.fillText(el.name, this.x + 15, currentY);
            if (el.status !== 'Active') {
                ctx.fillStyle = el.status === 'Error' ? '#da3633' : '#d29922';
                ctx.beginPath();
                ctx.arc(this.x + 8, currentY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            currentY += 25;
        });

        this.drawPorts(ctx);

        // Draw resize handle at bottom-right corner (outside node)
        if (isSelected) {
            const handleSize = 10;
            const offset = 5;
            ctx.fillStyle = '#58a6ff';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(
                this.x + this.width + offset,
                this.y + this.height + offset,
                handleSize / 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.stroke();
        }
    }

    drawPorts(ctx) {
        ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif';
        ctx.textBaseline = 'middle';

        const drawPort = (port, x, y, side) => {
            ctx.fillStyle = '#161b22';
            ctx.strokeStyle = '#8b949e';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#8b949e';
            if (side === 'left') {
                ctx.textAlign = 'right';
                ctx.fillText(port.name, x - 8, y);
            } else if (side === 'right') {
                ctx.textAlign = 'left';
                ctx.fillText(port.name, x + 8, y);
            } else if (side === 'top') {
                ctx.textAlign = 'center';
                ctx.fillText(port.name, x, y - 10);
            } else if (side === 'bottom') {
                ctx.textAlign = 'center';
                ctx.fillText(port.name, x, y + 10);
            }
        };

        const leftSpacing = this.height / (this.leftPorts.length + 1);
        this.leftPorts.forEach((port, index) => {
            drawPort(port, this.x, this.y + leftSpacing * (index + 1), 'left');
        });

        const rightSpacing = this.height / (this.rightPorts.length + 1);
        this.rightPorts.forEach((port, index) => {
            drawPort(port, this.x + this.width, this.y + rightSpacing * (index + 1), 'right');
        });

        const topSpacing = this.width / (this.topPorts.length + 1);
        this.topPorts.forEach((port, index) => {
            drawPort(port, this.x + topSpacing * (index + 1), this.y, 'top');
        });

        const bottomSpacing = this.width / (this.bottomPorts.length + 1);
        this.bottomPorts.forEach((port, index) => {
            drawPort(port, this.x + bottomSpacing * (index + 1), this.y + this.height, 'bottom');
        });
    }
}

// ===== Group Class =====
class Group {
    constructor(x, y, width, height) {
        this.id = state.nextGroupId++;
        this.x = x;
        this.y = y;
        this.width = width || 300;
        this.height = height || 200;
        this.label = `グループ ${this.id}`;
        this.color = '#30363d';
        this.backgroundColor = 'rgba(22, 27, 34, 0.5)';
        this.children = [];
        this.parentId = null;
    }

    containsPoint(x, y) {
        return x >= this.x && x <= this.x + this.width &&
            y >= this.y && y <= this.y + this.height;
    }

    getResizeHandleAtPosition(x, y) {
        const handleSize = 10;
        const handleX = this.x + this.width;
        const handleY = this.y + this.height;

        if (x >= handleX - handleSize && x <= handleX + handleSize &&
            y >= handleY - handleSize && y <= handleY + handleSize) {
            return 'bottom-right';
        }
        return null;
    }

    autoResize() {
        if (this.children.length === 0) return;

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasChildren = false;

        this.children.forEach(childId => {
            const node = state.nodes.find(n => n.id === childId);
            if (node) {
                hasChildren = true;
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + node.width);
                maxY = Math.max(maxY, node.y + node.height);
            }
            const group = state.groups.find(g => g.id === childId);
            if (group) {
                hasChildren = true;
                minX = Math.min(minX, group.x);
                minY = Math.min(minY, group.y);
                maxX = Math.max(maxX, group.x + group.width);
                maxY = Math.max(maxY, group.y + group.height);
            }
        });

        if (hasChildren) {
            const padding = 20;
            const headerHeight = 30;
            this.x = minX - padding;
            this.y = minY - headerHeight - padding;
            this.width = (maxX - minX) + (padding * 2);
            this.height = (maxY - minY) + headerHeight + (padding * 2);
        }
    }

    draw(ctx, isSelected) {
        ctx.fillStyle = this.backgroundColor;
        ctx.fillRect(this.x, this.y, this.width, this.height);

        ctx.strokeStyle = isSelected ? '#58a6ff' : this.color;
        ctx.lineWidth = isSelected ? 2 : 1;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        ctx.setLineDash([]);

        ctx.fillStyle = '#161b22';
        const labelPadding = 8;
        ctx.font = '12px "Segoe UI"';
        const labelWidth = ctx.measureText(this.label).width + labelPadding * 2;
        ctx.fillRect(this.x + 10, this.y - 10, labelWidth, 20);

        ctx.fillStyle = '#8b949e';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.label, this.x + 10 + labelPadding, this.y);

        // Draw resize handle if selected
        if (isSelected) {
            const handleSize = 8;
            ctx.fillStyle = '#58a6ff';
            ctx.fillRect(
                this.x + this.width - handleSize,
                this.y + this.height - handleSize,
                handleSize,
                handleSize
            );
        }
    }
}

// ===== Connection Class =====
class Connection {
    constructor(fromNodeId, fromPortId, toNodeId, toPortId) {
        this.id = state.nextConnectionId++;
        this.fromNodeId = fromNodeId;
        this.fromPortId = fromPortId;
        this.toNodeId = toNodeId;
        this.toPortId = toPortId;
        this.name = '';
        this.color = '#58a6ff';
        this.lineStyle = 'solid'; // 'solid' or 'dashed'
    }

    draw(ctx, isSelected) {
        const fromNode = state.nodes.find(n => n.id === this.fromNodeId);
        const toNode = state.nodes.find(n => n.id === this.toNodeId);
        if (!fromNode || !toNode) return;

        const fromPos = fromNode.getPortPosition(this.fromPortId);
        const toPos = toNode.getPortPosition(this.toPortId);
        if (!fromPos || !toPos) return;

        // Use connection color or default
        ctx.strokeStyle = isSelected ? '#f85149' : this.color;
        ctx.lineWidth = isSelected ? 3 : 2;

        // Set line style
        if (this.lineStyle === 'dashed') {
            ctx.setLineDash([8, 4]);
        } else {
            ctx.setLineDash([]);
        }

        ctx.beginPath();
        ctx.moveTo(fromPos.x, fromPos.y);

        const dx = Math.abs(toPos.x - fromPos.x);
        const dy = Math.abs(toPos.y - fromPos.y);
        const offset = Math.min(Math.max(dx, dy) * 0.5, 100);

        let cp1x = fromPos.x, cp1y = fromPos.y, cp2x = toPos.x, cp2y = toPos.y;

        switch (fromPos.side) {
            case 'left': cp1x -= offset; break;
            case 'right': cp1x += offset; break;
            case 'top': cp1y -= offset; break;
            case 'bottom': cp1y += offset; break;
        }

        switch (toPos.side) {
            case 'left': cp2x -= offset; break;
            case 'right': cp2x += offset; break;
            case 'top': cp2y -= offset; break;
            case 'bottom': cp2y += offset; break;
        }

        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toPos.x, toPos.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw connection name at midpoint if it exists
        if (this.name) {
            // Calculate midpoint of bezier curve (t=0.5)
            const t = 0.5;
            const mt = 1 - t;
            const midX = mt * mt * mt * fromPos.x + 3 * mt * mt * t * cp1x + 3 * mt * t * t * cp2x + t * t * t * toPos.x;
            const midY = mt * mt * mt * fromPos.y + 3 * mt * mt * t * cp1y + 3 * mt * t * t * cp2y + t * t * t * toPos.y;

            // Draw background for text
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif';
            const textWidth = ctx.measureText(this.name).width;
            const padding = 6;

            ctx.fillStyle = '#1c2128';
            ctx.fillRect(midX - textWidth / 2 - padding, midY - 10, textWidth + padding * 2, 20);

            // Draw text
            ctx.fillStyle = this.color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.name, midX, midY);
        }
    }

    isNearPoint(x, y, threshold = 10) {
        const fromNode = state.nodes.find(n => n.id === this.fromNodeId);
        const toNode = state.nodes.find(n => n.id === this.toNodeId);
        if (!fromNode || !toNode) return false;

        const fromPos = fromNode.getPortPosition(this.fromPortId);
        const toPos = toNode.getPortPosition(this.toPortId);
        if (!fromPos || !toPos) return false;

        const dx = Math.abs(toPos.x - fromPos.x);
        const dy = Math.abs(toPos.y - fromPos.y);
        const offset = Math.min(Math.max(dx, dy) * 0.5, 100);

        let cp1x = fromPos.x, cp1y = fromPos.y, cp2x = toPos.x, cp2y = toPos.y;

        switch (fromPos.side) {
            case 'left': cp1x -= offset; break;
            case 'right': cp1x += offset; break;
            case 'top': cp1y -= offset; break;
            case 'bottom': cp1y += offset; break;
        }

        switch (toPos.side) {
            case 'left': cp2x -= offset; break;
            case 'right': cp2x += offset; break;
            case 'top': cp2y -= offset; break;
            case 'bottom': cp2y += offset; break;
        }

        for (let t = 0; t <= 1; t += 0.05) {
            const mt = 1 - t;
            const px = mt * mt * mt * fromPos.x + 3 * mt * mt * t * cp1x + 3 * mt * t * t * cp2x + t * t * t * toPos.x;
            const py = mt * mt * mt * fromPos.y + 3 * mt * mt * t * cp1y + 3 * mt * t * t * cp2y + t * t * t * toPos.y;
            const dist = Math.sqrt((x - px) * (x - px) + (y - py) * (y - py));
            if (dist < threshold) return true;
        }
        return false;
    }
}
