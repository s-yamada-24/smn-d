});

document.getElementById('addGroupBtn').addEventListener('click', () => {
    let x, y;
    if (state.selectedGroup) {
        x = state.selectedGroup.x + 20;
        y = state.selectedGroup.y + 40;
    } else {
        x = snapToGrid((canvas.width / 2 - state.offset.x) / state.scale - 150);
        y = snapToGrid((canvas.height / 2 - state.offset.y) / state.scale - 100);
    }

    const group = new Group(x, y);
    state.groups.push(group);

    if (state.selectedGroup) {
        state.selectedGroup.children.push(group.id);
        group.parentId = state.selectedGroup.id;
    }

    state.selectedGroup = group;
    state.selectedNode = null;
    state.selectedConnection = null;
    updatePropertiesPanel();
    render();
});

document.getElementById('saveBtn').addEventListener('click', () => {
    const data = {
        title: document.getElementById('diagramTitle').textContent,
        nodes: state.nodes.map(n => ({
            id: n.id,
            x: n.x,
            y: n.y,
            width: n.width,
            height: n.height,
            label: n.label,
            color: n.color,
            memo: n.memo,
            elements: n.elements,
            leftPorts: n.leftPorts,
            rightPorts: n.rightPorts,
            topPorts: n.topPorts,
            bottomPorts: n.bottomPorts,
            parentId: n.parentId
        })),
        groups: state.groups.map(g => ({
            id: g.id,
            x: g.x,
            y: g.y,
            width: g.width,
            height: g.height,
            label: g.label,
            color: g.color,
            backgroundColor: g.backgroundColor,
            children: g.children,
            parentId: g.parentId
        })),
        connections: state.connections.map(c => ({
            id: c.id,
            fromNodeId: c.fromNodeId,
            fromPortId: c.fromPortId,
            toNodeId: c.toNodeId,
            toPortId: c.toPortId
        }))
    };

    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'network-diagram.json';
    a.click();
    URL.revokeObjectURL(url);
});

document.getElementById('loadBtn').addEventListener('click', () => {
    document.getElementById('fileInput').click();
});

document.getElementById('fileInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const data = JSON.parse(event.target.result);

            if (data.title) {
                document.getElementById('diagramTitle').textContent = data.title;
                state.diagramTitle = data.title;
            }

            state.nodes = [];
            state.connections = [];
            state.groups = [];
            state.selectedNode = null;
            state.selectedConnection = null;
            state.selectedGroup = null;

            data.nodes.forEach(nodeData => {
                const node = new NetworkNode(nodeData.x, nodeData.y);
                node.id = nodeData.id;
                node.width = nodeData.width;
                node.height = nodeData.height;
                node.label = nodeData.label;
                node.color = nodeData.color;
                node.memo = nodeData.memo;
                node.elements = nodeData.elements || [];
                node.leftPorts = nodeData.leftPorts || [];
                node.rightPorts = nodeData.rightPorts || [];
                node.topPorts = nodeData.topPorts || [];
                node.bottomPorts = nodeData.bottomPorts || [];
                node.parentId = nodeData.parentId || null;
                state.nodes.push(node);

                if (node.id >= state.nextNodeId) {
                    state.nextNodeId = node.id + 1;
                }
            });

            if (data.groups) {
                data.groups.forEach(groupData => {
                    const group = new Group(groupData.x, groupData.y, groupData.width, groupData.height);
                    group.id = groupData.id;
                    group.label = groupData.label;
                    group.color = groupData.color;
                    group.backgroundColor = groupData.backgroundColor || 'rgba(22, 27, 34, 0.5)';
                    group.children = groupData.children || [];
                    group.parentId = groupData.parentId || null;
                    state.groups.push(group);

                    if (group.id >= state.nextGroupId) {
                        state.nextGroupId = group.id + 1;
                    }
                });
            }

            data.connections.forEach(connData => {
                const conn = new Connection(
                    connData.fromNodeId,
                    connData.fromPortId,
                    connData.toNodeId,
                    connData.toPortId
                );
                conn.id = connData.id;
                state.connections.push(conn);

                if (conn.id >= state.nextConnectionId) {
                    state.nextConnectionId = conn.id + 1;
                }
            });

            updatePropertiesPanel();
            render();
        } catch (error) {
            alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
        }
    };
    reader.readAsText(file);
    e.target.value = '';
});

document.getElementById('exportBtn').addEventListener('click', () => {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');

    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    state.nodes.forEach(node => {
        minX = Math.min(minX, node.x - 50);
        minY = Math.min(minY, node.y - 50);
        maxX = Math.max(maxX, node.x + node.width + 50);
        maxY = Math.max(maxY, node.y + node.height + 50);
    });

    if (state.nodes.length === 0) {
        alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“');
        return;
    }

    tempCanvas.width = maxX - minX;
    tempCanvas.height = maxY - minY;

    tempCtx.fillStyle = '#0d1117';
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

    tempCtx.translate(-minX, -minY);

    state.groups.forEach(group => group.draw(tempCtx, false));
    state.connections.forEach(conn => conn.draw(tempCtx, false));
    state.nodes.forEach(node => node.draw(tempCtx, false));

    tempCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'network-diagram.png';
        a.click();
        URL.revokeObjectURL(url);
    });
});

document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete') {
        if (state.selectedNode) {
            const index = state.nodes.indexOf(state.selectedNode);
            if (index > -1) {
                const nodeId = state.selectedNode.id;
                state.nodes.splice(index, 1);

                state.connections = state.connections.filter(
                    c => c.fromNodeId !== nodeId && c.toNodeId !== nodeId
                );

                state.selectedNode = null;
                updatePropertiesPanel();
                render();
            }
        } else if (state.selectedConnection) {
            const index = state.connections.indexOf(state.selectedConnection);
            if (index > -1) {
                state.connections.splice(index, 1);
                state.selectedConnection = null;
                updatePropertiesPanel();
                render();
            }
        } else if (state.selectedGroup) {
            const index = state.groups.indexOf(state.selectedGroup);
            if (index > -1) {
                state.groups.splice(index, 1);
                state.selectedGroup = null;
                updatePropertiesPanel();
                render();
            }
        }
    }
});

// ===== Resize Logic =====
const bottomPanel = document.getElementById('bottomPanel');
const resizeHandle = document.getElementById('resizeHandle');
let isResizing = false;
let lastY = 0;

resizeHandle.addEventListener('mousedown', (e) => {
    isResizing = true;
    lastY = e.clientY;
    resizeHandle.classList.add('active');
    document.body.style.cursor = 'ns-resize';
    e.preventDefault(); // Prevent text selection
});

document.addEventListener('mousemove', (e) => {
    if (!isResizing) return;

    const deltaY = lastY - e.clientY;
    const currentHeight = bottomPanel.offsetHeight;
    const newHeight = currentHeight + deltaY;

    // Constraints are handled by CSS min/max-height, but we can add logic here if needed
    bottomPanel.style.height = `${newHeight}px`;
    lastY = e.clientY;

    resizeCanvas(); // Resize canvas as panel height changes
});

document.addEventListener('mouseup', () => {
    if (isResizing) {
        isResizing = false;
        resizeHandle.classList.remove('active');
        document.body.style.cursor = 'default';
        resizeCanvas(); // Final resize
    }
});

// ===== Properties Panel & Tabs =====
// Tab State
let activeTab = 'basic';

// Initialize Tabs
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        // Update active tab state
        activeTab = btn.dataset.tab;

        // Update UI
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

        btn.classList.add('active');
        document.getElementById(`tab-${activeTab}`).classList.add('active');
    });
});

function updatePropertiesPanel() {
    const basicTab = document.getElementById('tab-basic');
    const elementsTab = document.getElementById('tab-elements');
    const portsTab = document.getElementById('tab-ports');

    if (state.selectedConnection) {
        renderConnectionProperties(basicTab, elementsTab, portsTab);
        return;
    }

    if (state.selectedGroup) {
        renderGroupProperties(basicTab, elementsTab, portsTab);
        return;
    }

    if (!state.selectedNode) {
        basicTab.innerHTML = '<p class="empty-state">ãƒãƒ¼ãƒ‰ã€æ¥ç¶šã€ã¾ãŸã¯ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„</p>';
        elementsTab.innerHTML = '<p class="empty-state">ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„</p>';
        portsTab.innerHTML = '<p class="empty-state">ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„</p>';
        return;
    }

    const node = state.selectedNode;

    // === Basic Tab ===
    basicTab.innerHTML = `
        <table class="properties-table">
            <tr>
                <th>çŠ¶æ…‹</th>
                <td>
                    <select id="nodeStatus">
                        <option value="Active" ${node.status === 'Active' ? 'selected' : ''}>Active</option>
                        <option value="Inactive" ${node.status === 'Inactive' ? 'selected' : ''}>Inactive</option>
                    </select>
                </td>
            </tr>
            <tr>
                <th>åç§°</th>
                <td><input type="text" id="nodeName" value="${node.label}"></td>
            </tr>
            <tr>
                <th>åˆ†é¡</th>
                <td>
                    <select id="nodeClassification">
                        <option value="PC" ${node.classification === 'PC' ? 'selected' : ''}>PC</option>
                        <option value="NAS" ${node.classification === 'NAS' ? 'selected' : ''}>NAS</option>
                        <option value="Switching Hub" ${node.classification === 'Switching Hub' ? 'selected' : ''}>Switching Hub</option>
                        <option value="FW" ${node.classification === 'FW' ? 'selected' : ''}>FW</option>
                        <option value="Network Connected Device" ${node.classification === 'Network Connected Device' ? 'selected' : ''}>Network Connected Device</option>
                        <option value="Keyboard" ${node.classification === 'Keyboard' ? 'selected' : ''}>Keyboard</option>
                        <option value="Mouse" ${node.classification === 'Mouse' ? 'selected' : ''}>Mouse</option>
                        <option value="Display" ${node.classification === 'Display' ? 'selected' : ''}>Display</option>
                    </select>
                </td>
            </tr>
            <tr>
                <th>ç®¡ç†ç•ªå·</th>
                <td><input type="text" id="nodeManagementId" value="${node.managementId || ''}"></td>
            </tr>
            <tr>
                <th>å‹ç•ª</th>
                <td><input type="text" id="nodeModelNumber" value="${node.modelNumber || ''}"></td>
            </tr>
            <tr>
                <th>ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³</th>
                <td><input type="text" id="nodeLocation" value="${node.location || ''}"></td>
            </tr>
            <tr>
                <th>å°å…¥æ—¥</th>
                <td><input type="date" id="nodeInstallDate" value="${node.installDate || ''}"></td>
            </tr>
            <tr>
                <th>å»ƒæ£„æ—¥</th>
                <td><input type="date" id="nodeDisposalDate" value="${node.disposalDate || ''}"></td>
            </tr>
            <tr>
                <th>ãƒ¡ãƒ¢</th>
                <td><textarea id="nodeMemo">${node.memo}</textarea></td>
            </tr>
            <tr>
                <th>è‰²</th>
                <td>
                    <div class="color-picker-wrapper">
                        <input type="color" class="color-picker" id="nodeColor" value="${node.color}">
                        <input type="text" class="color-value" id="nodeColorValue" value="${node.color}" readonly>
                    </div>
                </td>
            </tr>
            <tr>
                <th>å¹… (px)</th>
                <td><input type="number" id="nodeWidth" value="${node.width}" min="50"></td>
            </tr>
        </table>
    `;

    // === Elements Tab ===
    elementsTab.innerHTML = `
        <div class="section-header">
            <span class="section-title">è¦ç´ ä¸€è¦§</span>
            <button class="btn btn-secondary btn-sm" id="addElement">+ è¿½åŠ </button>
        </div>
        <div id="elementsList"></div>
    `;

    // === Ports Tab ===
    portsTab.innerHTML = `
        <div class="section-header">
            <span class="section-title">ä¸Šå´ãƒãƒ¼ãƒˆ</span>
            <button class="btn btn-secondary btn-sm" id="addTopPort">+ è¿½åŠ </button>
        </div>
        <div id="topPortsList"></div>

        <div class="section-header" style="margin-top: 20px;">
            <span class="section-title">å·¦å´ãƒãƒ¼ãƒˆ</span>
            <button class="btn btn-secondary btn-sm" id="addLeftPort">+ è¿½åŠ </button>
        </div>
        <div id="leftPortsList"></div>
        
        <div class="section-header" style="margin-top: 20px;">
            <span class="section-title">å³å´ãƒãƒ¼ãƒˆ</span>
            <button class="btn btn-secondary btn-sm" id="addRightPort">+ è¿½åŠ </button>
        </div>
        <div id="rightPortsList"></div>

        <div class="section-header" style="margin-top: 20px;">
            <span class="section-title">ä¸‹å´ãƒãƒ¼ãƒˆ</span>
            <button class="btn btn-secondary btn-sm" id="addBottomPort">+ è¿½åŠ </button>
        </div>
        <div id="bottomPortsList"></div>
    `;

    // Attach Event Listeners
    attachNodeListeners(node);
    updateElementList();
    updatePortList('top');
    updatePortList('left');
    updatePortList('right');
    updatePortList('bottom');

    document.getElementById('addElement').addEventListener('click', () => {
        node.addElement();
        updateElementList();
        render();
    });

    document.getElementById('addTopPort').addEventListener('click', () => { addPort(node, 'top'); });
    document.getElementById('addLeftPort').addEventListener('click', () => { addPort(node, 'left'); });
    document.getElementById('addRightPort').addEventListener('click', () => { addPort(node, 'right'); });
    document.getElementById('addBottomPort').addEventListener('click', () => { addPort(node, 'bottom'); });
}

function renderConnectionProperties(basicTab, elementsTab, portsTab) {
    const conn = state.selectedConnection;
    const fromNode = state.nodes.find(n => n.id === conn.fromNodeId);
    const toNode = state.nodes.find(n => n.id === conn.toNodeId);

    basicTab.innerHTML = `
        <table class="properties-table">
            <tr>
                <th>æ¥ç¶šå…ƒ</th>
                <td>${fromNode ? fromNode.label : 'ä¸æ˜'}</td>
            </tr>
            <tr>
                <th>æ¥ç¶šå…ˆ</th>
                <td>${toNode ? toNode.label : 'ä¸æ˜'}</td>
            </tr>
        </table>
        <div style="margin-top: 16px;">
            <button class="btn btn-secondary" id="reconnectBtn" style="width: 100%; margin-bottom: 8px;">ğŸ”„ æ¥ç¶šã‚’ç¹‹ãå¤‰ãˆã‚‹</button>
            <button class="btn btn-secondary" id="deleteConnectionBtn" style="width: 100%; background: #da3633; border-color: #da3633;">ğŸ—‘ï¸ æ¥ç¶šã‚’å‰Šé™¤</button>
        </div>
    `;
    elementsTab.innerHTML = '<p class="empty-state">æ¥ç¶šã«ã¯è¦ç´ ãŒã‚ã‚Šã¾ã›ã‚“</p>';
    portsTab.innerHTML = '<p class="empty-state">æ¥ç¶šã«ã¯ãƒãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</p>';

    document.getElementById('deleteConnectionBtn').addEventListener('click', () => {
        const index = state.connections.indexOf(state.selectedConnection);
        if (index > -1) {
            state.connections.splice(index, 1);
            state.selectedConnection = null;
            updatePropertiesPanel();
            render();
        }
    });

    document.getElementById('reconnectBtn').addEventListener('click', () => {
        state.isConnecting = true;
        state.connectionStart = {
            nodeId: conn.fromNodeId,
            portId: conn.fromPortId,
            reconnecting: true,
            oldConnection: conn
        };
        state.selectedConnection = null;
        updatePropertiesPanel();
        render();
    });
}

function renderGroupProperties(basicTab, elementsTab, portsTab) {
    const group = state.selectedGroup;
    basicTab.innerHTML = `
        <table class="properties-table">
            <tr>
                <th>ã‚°ãƒ«ãƒ¼ãƒ—å</th>
                <td><input type="text" id="groupName" value="${group.label}"></td>
            </tr>
            <tr>
                <th>å¹… (px)</th>
                <td><input type="number" id="groupWidth" value="${group.width}" min="50"></td>
            </tr>
            <tr>
                <th>é«˜ã• (px)</th>
                <td><input type="number" id="groupHeight" value="${group.height}" min="50"></td>
            </tr>
            <tr>
                <th>èƒŒæ™¯è‰²</th>
                <td>
                    <div class="color-picker-wrapper">
                        <input type="color" class="color-picker" id="groupBgColor" value="${rgbaToHex(group.backgroundColor)}">
                        <input type="number" id="groupBgOpacity" value="${getOpacityFromRgba(group.backgroundColor)}" min="0" max="100" step="1" style="width: 60px; margin-left: 8px;">
                        <span style="margin-left: 4px;">%</span>
                    </div>
                </td>
            </tr>
        </table>
    `;

    // Elements Tab - Show Children
    if (group.children.length === 0) {
        elementsTab.innerHTML = '<p class="empty-state">å­è¦ç´ ãŒã‚ã‚Šã¾ã›ã‚“</p>';
    } else {
        let html = `
            <div class="section-header">
                <span class="section-title">å­è¦ç´ ä¸€è¦§</span>
            </div>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>ç¨®é¡</th>
                        <th>åç§°</th>
                        <th>ID</th>
                    </tr>
                </thead>
                <tbody>
        `;

        group.children.forEach(childId => {
            const node = state.nodes.find(n => n.id === childId);
            const childGroup = state.groups.find(g => g.id === childId);

            if (node) {
                html += `
                    <tr>
                        <td>ãƒãƒ¼ãƒ‰</td>
                        <td>${node.label}</td>
                        <td>${node.id}</td>
                    </tr>
                `;
            } else if (childGroup) {
                html += `
                    <tr>
                        <td>ã‚°ãƒ«ãƒ¼ãƒ—</td>
                        <td>${childGroup.label}</td>
                        <td>${childGroup.id}</td>
                    </tr>
                `;
            }
        });

        html += '</tbody></table>';
        elementsTab.innerHTML = html;
    }

    portsTab.innerHTML = '<p class="empty-state">ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¯ãƒãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</p>';

    document.getElementById('groupName').addEventListener('input', (e) => { group.label = e.target.value; render(); });
    document.getElementById('groupWidth').addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        if (!isNaN(val) && val > 0) { group.width = val; render(); }
    });
    document.getElementById('groupHeight').addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        if (!isNaN(val) && val > 0) { group.height = val; render(); }
    });

    document.getElementById('groupBgColor').addEventListener('input', (e) => {
        const hex = e.target.value;
        const opacity = parseInt(document.getElementById('groupBgOpacity').value) / 100;
        group.backgroundColor = hexToRgba(hex, opacity);
        render();
    });

    document.getElementById('groupBgOpacity').addEventListener('input', (e) => {
        const opacity = parseInt(e.target.value) / 100;
        const hex = document.getElementById('groupBgColor').value;
        group.backgroundColor = hexToRgba(hex, opacity);
        render();
    });
}

// Helper functions for color conversion
function rgbaToHex(rgba) {
    const match = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (!match) return '#161b22';
    const r = parseInt(match[1]).toString(16).padStart(2, '0');
    const g = parseInt(match[2]).toString(16).padStart(2, '0');
    const b = parseInt(match[3]).toString(16).padStart(2, '0');
    return `#${r}${g}${b}`;
}

function getOpacityFromRgba(rgba) {
    const match = rgba.match(/rgba?\([^,]+,[^,]+,[^,]+,?\s*([\d.]+)?\)/);
    if (!match || !match[1]) return 50;
    return Math.round(parseFloat(match[1]) * 100);
}

function hexToRgba(hex, opacity) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
}

function attachNodeListeners(node) {
    const mapping = {
        'nodeStatus': 'status',
        'nodeName': 'label',
        'nodeClassification': 'classification',
        'nodeManagementId': 'managementId',
        'nodeModelNumber': 'modelNumber',
        'nodeLocation': 'location',
        'nodeInstallDate': 'installDate',
        'nodeDisposalDate': 'disposalDate',
        'nodeMemo': 'memo'
    };

    for (const [id, prop] of Object.entries(mapping)) {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener('input', (e) => {
                node[prop] = e.target.value;
                if (prop === 'label') render();
            });
        }
    }

    document.getElementById('nodeWidth').addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        if (!isNaN(val) && val > 0) {
            node.width = val;
            render();
        }
    });

    document.getElementById('nodeColor').addEventListener('input', (e) => {
        node.color = e.target.value;
        document.getElementById('nodeColorValue').value = e.target.value;
        render();
    });
}

function updateElementList() {
    const node = state.selectedNode;
    if (!node) return;

    const list = document.getElementById('elementsList');
    if (!list) return;

    if (node.elements.length === 0) {
        list.innerHTML = '<p class="empty-state" style="padding: 10px;">è¦ç´ ãŒã‚ã‚Šã¾ã›ã‚“</p>';
        return;
    }

    let html = `
        <table class="data-table">
            <thead>
                <tr>
                    <th style="width: 80px;">çŠ¶æ…‹</th>
                    <th>åç§°</th>
                    <th>ãƒ¡ãƒ¢1</th>
                    <th>ãƒ¡ãƒ¢2</th>
                    <th>URL</th>
                    <th style="width: 60px;">è‰²</th>
                    <th class="action-cell">é †åº</th>
                    <th class="action-cell"></th>
                </tr>
            </thead>
            <tbody>
    `;

    node.elements.forEach((el, index) => {
        html += `
            <tr>
                <td>
                    <select onchange="updateElementField(${index}, 'status', this.value)">
                        <option value="Active" ${el.status === 'Active' ? 'selected' : ''}>Active</option>
                        <option value="Inactive" ${el.status === 'Inactive' ? 'selected' : ''}>Inactive</option>
                    </select>
                </td>
                <td><input type="text" value="${el.name}" onchange="updateElementField(${index}, 'name', this.value)"></td>
                <td><textarea onchange="updateElementField(${index}, 'memo1', this.value)">${el.memo1 || ''}</textarea></td>
                <td><textarea onchange="updateElementField(${index}, 'memo2', this.value)">${el.memo2 || ''}</textarea></td>
                <td><input type="text" value="${el.url || ''}" onchange="updateElementField(${index}, 'url', this.value)"></td>
                <td><input type="color" value="${el.color || '#c9d1d9'}" onchange="updateElementField(${index}, 'color', this.value)" style="height: 30px;"></td>
                <td class="action-cell">
                    <button class="btn-icon" onclick="moveElement(${index}, -1)" ${index === 0 ? 'disabled' : ''}>â–²</button>
                    <button class="btn-icon" onclick="moveElement(${index}, 1)" ${index === node.elements.length - 1 ? 'disabled' : ''}>â–¼</button>
                </td>
                <td class="action-cell">
                    <button class="btn-icon" onclick="deleteElement(${index})">ğŸ—‘ï¸</button>
                </td>
            </tr>
        `;
    });

    html += '</tbody></table>';
    list.innerHTML = html;
}

function updatePortList(side) {
    const node = state.selectedNode;
    if (!node) return;

    let ports, listId;
    if (side === 'left') { ports = node.leftPorts; listId = 'leftPortsList'; }
    else if (side === 'right') { ports = node.rightPorts; listId = 'rightPortsList'; }
    else if (side === 'top') { ports = node.topPorts; listId = 'topPortsList'; }
    else if (side === 'bottom') { ports = node.bottomPorts; listId = 'bottomPortsList'; }

    const list = document.getElementById(listId);
    if (!list) return;

    if (ports.length === 0) {
        list.innerHTML = '<p class="empty-state" style="padding: 10px;">ãƒãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</p>';
        return;
    }

    let html = `
        <table class="data-table">
            <thead>
                <tr>
                    <th style="width: 80px;">çŠ¶æ…‹</th>
                    <th>åç§°</th>
                    <th>åˆ†é¡</th>
                    <th>å‹ç•ª</th>
                    <th>ãƒ¡ãƒ¢</th>
                    <th class="action-cell">é †åº</th>
                    <th class="action-cell"></th>
                </tr>
            </thead>
            <tbody>
    `;

    ports.forEach((port, index) => {
        html += `
            <tr>
                <td>
                    <select onchange="updatePortField('${side}', ${index}, 'status', this.value)">
                        <option value="Active" ${port.status === 'Active' ? 'selected' : ''}>Active</option>
                        <option value="Inactive" ${port.status === 'Inactive' ? 'selected' : ''}>Inactive</option>
                    </select>
                </td>
                <td><input type="text" value="${port.name}" onchange="updatePortField('${side}', ${index}, 'name', this.value)"></td>
                <td>
                    <select onchange="updatePortField('${side}', ${index}, 'classification', this.value)">
                        <option value="LAN" ${port.classification === 'LAN' ? 'selected' : ''}>LAN</option>
                        <option value="USB" ${port.classification === 'USB' ? 'selected' : ''}>USB</option>
                        <option value="COM" ${port.classification === 'COM' ? 'selected' : ''}>COM</option>
                        <option value="HDMI" ${port.classification === 'HDMI' ? 'selected' : ''}>HDMI</option>
                        <option value="DisplayPort" ${port.classification === 'DisplayPort' ? 'selected' : ''}>DisplayPort</option>
                    </select>
                </td>
                <td><input type="text" value="${port.modelNumber || ''}" onchange="updatePortField('${side}', ${index}, 'modelNumber', this.value)"></td>
                <td><input type="text" value="${port.memo || ''}" onchange="updatePortField('${side}', ${index}, 'memo', this.value)"></td>
                <td class="action-cell">
                    <button class="btn-icon" onclick="movePort('${side}', ${index}, -1)" ${index === 0 ? 'disabled' : ''}>â–²</button>
                    <button class="btn-icon" onclick="movePort('${side}', ${index}, 1)" ${index === ports.length - 1 ? 'disabled' : ''}>â–¼</button>
                </td>
                <td class="action-cell">
                    <button class="btn-icon" onclick="deletePort('${side}', ${index})">ğŸ—‘ï¸</button>
                </td>
            </tr>
        `;
    });

    html += '</tbody></table>';
    list.innerHTML = html;
}

// Helper functions attached to window for inline events
window.updateElementField = function (index, field, value) {
    const node = state.selectedNode;
    if (!node) return;
    node.elements[index][field] = value;
    if (field === 'name' || field === 'color') render();
};

window.deleteElement = function (index) {
    const node = state.selectedNode;
    if (!node) return;
    node.removeElement(index);
    updateElementList();
    render();
};

window.moveElement = function (index, direction) {
    const node = state.selectedNode;
    if (!node) return;

    const newIndex = index + direction;
    if (newIndex < 0 || newIndex >= node.elements.length) return;

    const temp = node.elements[index];
    node.elements[index] = node.elements[newIndex];
    node.elements[newIndex] = temp;

    updateElementList();
    render();
};

window.updatePortField = function (side, index, field, value) {
    const node = state.selectedNode;
    if (!node) return;

    let ports;
    if (side === 'left') ports = node.leftPorts;
    else if (side === 'right') ports = node.rightPorts;
    else if (side === 'top') ports = node.topPorts;
    else if (side === 'bottom') ports = node.bottomPorts;

    const port = ports[index];
    port[field] = value;
    if (field === 'name') render();
};

window.deletePort = function (side, index) {
    const node = state.selectedNode;
    if (!node) return;

    let ports;
    if (side === 'left') ports = node.leftPorts;
    else if (side === 'right') ports = node.rightPorts;
    else if (side === 'top') ports = node.topPorts;
    else if (side === 'bottom') ports = node.bottomPorts;

    const portId = ports[index].id;

    // Remove connections
    state.connections = state.connections.filter(c => c.fromPortId !== portId && c.toPortId !== portId);

    ports.splice(index, 1);
    updatePortList(side);
    render();
};

window.movePort = function (side, index, direction) {
    const node = state.selectedNode;
    if (!node) return;

    let ports;
    if (side === 'left') ports = node.leftPorts;
    else if (side === 'right') ports = node.rightPorts;
    else if (side === 'top') ports = node.topPorts;
    else if (side === 'bottom') ports = node.bottomPorts;

    const newIndex = index + direction;
    if (newIndex < 0 || newIndex >= ports.length) return;

    const temp = ports[index];
    ports[index] = ports[newIndex];
    ports[newIndex] = temp;

    updatePortList(side);
    render();
};

function addPort(node, side) {
    let ports, prefix;
    if (side === 'left') { ports = node.leftPorts; prefix = 'L'; }
    else if (side === 'right') { ports = node.rightPorts; prefix = 'R'; }
    else if (side === 'top') { ports = node.topPorts; prefix = 'T'; }
    else if (side === 'bottom') { ports = node.bottomPorts; prefix = 'B'; }

    const portNum = ports.length + 1;
    ports.push({
        name: `${prefix}${portNum}`,
        id: `${node.id}-${prefix}${Date.now()}`, // Use timestamp for unique ID to avoid collisions
        description: '',
        status: 'Active',
        classification: 'LAN',
        modelNumber: '',
        memo: ''
    });
    updatePortList(side);
    render();
}

render();
